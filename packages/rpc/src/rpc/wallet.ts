import { decoderawtransaction, getrawtransaction } from "./rawtransactions.js";

export type abandontransaction = null;

export type abortrescan = boolean;

export interface addmultisigaddress {
  // The value of the new multisig address
  address: string;
  // The string value of the hex-encoded redemption script
  redeemScript: string;
  // The descriptor for this multisig
  descriptor: string;
  // Any warnings resulting from the creation of this multisig
  warnings?: string[];
}

export type backupwallet = null;

export interface bumpfee {
  // The id of the new transaction.
  txid: string;
  // The fee of the replaced transaction.
  origfee: number;
  // The fee of the new transaction.
  fee: number;
  // Errors encountered during processing (may be empty).
  errors: string[];
}

export interface createwallet {
  // The wallet name if created successfully. If the wallet was created using a full path, the wallet_name will be the full path.
  name: string;
  // Warning message if wallet was not loaded cleanly.
  warning: string;
}

export type dumpprivkey = string;

export type encryptwallet = string;

export interface getaddressesbylabel {
  // json object with addresses as keys
  [key: string]: {
    // Purpose of address ("send" for sending address, "receive" for receiving address)
    purpose: string;
  }
}

export interface getaddressinfobase {
  // The bitcoin address validated.
  address: string;
  // The hex-encoded scriptPubKey generated by the address.
  scriptPubKey: string;
  // If we know how to spend coins sent to this address, ignoring the possible lack of private keys.
  solvable: boolean;
  // A descriptor for spending coins sent to this address (only when solvable).
  desc?: string;
  // The descriptor used to derive this address if this is a descriptor wallet
  parent_desc?: string;
  // If the key is a script.
  isscript: boolean;
  // If the address was used for change output.
  ischange: boolean;
  // If the address is a witness address.
  iswitness: boolean;
  // The version number of the witness program.
  witness_version?: number;
  // The hex value of the witness program.
  witness_program?: string;
  // The output script type. Only if isscript is true and the redeemscript is known. Possible types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash, witness_v0_scripthash, witness_unknown.
  script?: 'nonstandard' | 'pubkey' | 'pubkeyhash' | 'scripthash' | 'multisig' | 'nulldata' | 'witness_v0_keyhash' | 'witness_v0_scripthash' | 'witness_unknown';
  // The redeemscript for the p2sh address.
  hex?: string;
  // Array of pubkeys associated with the known redeemscript (only if script is multisig).
  pubkeys?: string[];
  // The number of signatures required to spend multisig output (only if script is multisig).
  sigsrequired?: number;
  // The hex value of the raw public key for single-key addresses (possibly embedded in P2SH or P2WSH).
  pubkey?: string;
  // If the pubkey is compressed.
  iscompressed?: boolean;
  // Array of labels associated with the address. Currently limited to one label but returned
  labels: string[]
}

export interface getaddressinfo extends getaddressinfobase {
  // If the address is yours.
  ismine: boolean;
  // If the address is watchonly.
  iswatchonly: boolean;
  // Information about the address embedded in P2SH or P2WSH, if relevant and known.
  embedded?: getaddressinfobase;
  // The creation time of the key, if available, expressed in UNIX epoch time.
  timestamp?: number;
  // The HD keypath, if the key is HD and available.
  hdkeypath?: string;
  // The Hash160 of the HD seed.
  hdseedid?: string;
  // The fingerprint of the master key.
  hdmasterfingerprint?: string;
}

export type getbalance = number;

export interface getbalances {
  // balances from outputs that the wallet can sign
  mine: {
    // trusted balance (outputs created by the wallet or confirmed outputs)
    trusted: number;
    // untrusted pending balance (outputs created by others that are in the mempool)
    untrusted_pending: number;
    // balance from immature coinbase outputs
    immature: number;
    // (only present if avoid_reuse is set) balance from coins sent to addresses that were previously spent from (potentially privacy violating)
    used?: number;
  }
  // watchonly balances (not present if wallet does not watch anything)
  watchonly?: {
    // trusted balance (outputs created by the wallet or confirmed outputs)
    trusted: number;
    // untrusted pending balance (outputs created by others that are in the mempool)
    untrusted_pending: number;
    // balance from immature coinbase outputs
    immature: number;
  }
}

export type getnewaddress = string;

export type getrawchangeaddress = string;

export type getreceivedbyaddress = number;

export type getreceivedbylabel = number;

export interface transactiondescription {
  // The number of confirmations for the transaction. Negative confirmations means the transaction conflicted that many blocks ago.
  confirmations: number;
  // Only present if the transaction's only input is a coinbase one.
  generated?: boolean;
  // Whether we consider the transaction to be trusted and safe to spend from. Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).
  trusted?: boolean;
  // The block hash containing the transaction.
  blockhash?: string;
  // The block height containing the transaction.
  blockheight?: number;
  // The index of the transaction in the block that includes it.
  blockindex?: number;
  // The block time expressed in UNIX epoch time.
  blocktime?: number;
  // The transaction id.
  txid: string;
  // The hash of serialized transaction, including witness data.
  wtxid: string;
  // Conflicting transaction ids.
  walletconflicts: string[];
  // The txid if this tx was replaced.
  replaced_by_txid?: string;
  // The txid if the tx replaces one.
  replaces_txid?: string;
  // If a comment to is associated with the transaction.
  to?: string;
  // The transaction time expressed in UNIX epoch time.
  time: number;
  // The time received expressed in UNIX epoch time.
  timereceived: number;
  // If a comment is associated with the transaction, only present if not empty.
  comment?: string;
  // Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. May be unknown for unconfirmed transactions not in the mempool because their unconfirmed ancestors are unknown.
  'bip125-replaceable': 'yes' | 'no' | 'unknown';
  // Only if 'category' is 'received'. List of parent descriptors for the scriptPubKey of this coin.
  parent_descs?: string[];
}

export interface gettransaction extends transactiondescription {
  // The amount in BTC
  amount: number;
  // The amount of the fee in BTC. This is negative and only available for the 'send' category of transactions.
  fee?: number;
  details: Array<{
    // Only returns true if imported addresses were involved in transaction.
    involvesWatchonly?: boolean;
    // The bitcoin address involved in the transaction.
    address?: string;
    // The transaction category.
    category: 'send' | 'receive' | 'generate' | 'immature' | 'orphan';
    // The amount in BTC
    amount: number;
    // A comment for the address/transaction, if any
    label?: string;
    // the vout value
    vout: number;
    // The amount of the fee in BTC. This is negative and only available for the 'send' category of transactions.
    fee: number;
    // 'true' if the transaction has been abandoned (inputs are respendable). Only available for the 'send' category of transactions.
    abandoned?: boolean;
    // Only if 'category' is 'received'. List of parent descriptors for the scriptPubKey of this coin.
    parent_descs?: string[];
  }>;
  // Raw data for transaction
  hex: string;
  // The decoded transaction (only present when `verbose` is passed)
  decoded?: getrawtransaction | decoderawtransaction;
}

export type getunconfirmedbalance = number;

export interface getwalletinfo {
  // the wallet name
  walletname: string;
  // the wallet version
  walletversion: number;
  // the database format (bdb or sqlite)
  format: string;
  // DEPRECATED. Identical to getbalances().mine.trusted
  balance: number;
  // DEPRECATED. Identical to getbalances().mine.untrusted_pending
  unconfirmed_balance: number;
  // DEPRECATED. Identical to getbalances().mine.immature
  immature_balance: number;
  // the total number of transactions in the wallet
  txcount: number;
  // the UNIX epoch time of the oldest pre-generated key in the key pool. Legacy wallets only.
  keypoololdest?: number;
  // how many new keys are pre-generated (only counts external keys)
  keypoolsize: number;
  // how many new keys are pre-generated for internal use (used for change outputs, only appears if the wallet is using this feature, otherwise external keys are used)
  keypoolsize_hd_internal?: number;
  // the UNIX epoch time until which the wallet is unlocked for transfers, or 0 if the wallet is locked (only present for passphrase-encrypted wallets)
  unlocked_until?: number;
  // the transaction fee configuration, set in BTC/kvB
  paytxfee: number;
  // the Hash160 of the HD seed (only present when HD is enabled)
  hdseedid?: string;
  // false if privatekeys are disabled for this wallet (enforced watch-only wallet)
  private_keys_enabled: boolean;
  // whether this wallet tracks clean/dirty coins in terms of reuse
  avoid_reuse: boolean;
  // current scanning details, or false if no scan is in progress
  scanning?: false | {
    // elapsed seconds since scan start
    duration: number;
    // scanning progress percentage [0.0, 1.0]
    progress: number;
  }
  // whether this wallet uses descriptors for scriptPubKey management
  descriptors: boolean;
  // whether this wallet is configured to use an external signer such as a hardware wallet
  external_signer: boolean;
}

export type importaddress = null;

export type importdescriptors = [{
  success: boolean;
  warnings?: string[];
  // @todo JSON RPC error type
  error?: Record<any, any>;
}]

export type importmulti = [{
  success: boolean;
  warnings?: string[];
  // @todo JSON RPC error type
  error?: Record<any, any>;
}]

export type importprivkey = null;

export type importprunedfunds = null;

export type importpubkey = null;

export type importwallet = null;

export type keypoolrefill = null;

export type listaddressgroupings = Array<Array<[string, number, string?]>>;

export interface listdescriptors {
  // Name of wallet this operation was performed on
  wallet_name: string;
  descriptors: Array<{
    // Descriptor string representation
    desc: string;
    // The creation time of the descriptor
    timestamp: number;
    // Whether this descriptor is currently used to generate new addresses
    active: boolean;
    // True if this descriptor is used to generate change addresses. False if this descriptor is used to generate receiving addresses; defined only for active descriptors
    internal?: boolean;
    // Defined only for ranged descriptors
    range?: [number, number];
    // The next index to generate addresses from; defined only for ranged descriptors
    next?: number;
  }>;
}

export type listlabels = string[];

export type listlockunspent = Array<{
  // The transaction id locked
  txid: string;
  // The vout value
  vout: number;
}>;

export type listreceivedbyaddress = Array<{
  // Only returns true if imported addresses were involved in transaction
  involvesWatchonly?: boolean;
  // The receiving address
  address: string;
  // The total amount in BTC received by the address
  amount: number;
  // The number of confirmations of the most recent transaction included
  confirmations: number;
  // The label of the receiving address. The default label is ""
  label: string;
  // The ids of transactions received with the address
  txids: string[];
}>;

export type listreceivedbylabel = Array<{
  // Only returns true if imported addresses were involved in transaction
  involvesWatchonly?: boolean;
  // The receiving address
  address: string;
  // The total amount in BTC received by the address
  amount: number;
  // The number of confirmations of the most recent transaction included
  confirmations: number;
  // The label of the receiving address. The default label is ""
  label: string;
}>;

export interface extendedtransactiondescription extends transactiondescription {
  // Only returns true if imported addresses were involved in transaction
  involvesWatchonly?: boolean;
  // The bitcoin address of the transaction (not returned if the output does not have an address, e.g. OP_RETURN null data).
  address?: string;
  // The transaction category.
  category: 'send' | 'receive' | 'generate' | 'immature' | 'orphan';
  // The amount in BTC. This is negative for the 'send' category, and is positive
  amount: number;
  // The amount of the fee in BTC. This is negative and only available for the 'send' category of transactions.
  fee?: number;
  // 'true' if the transaction has been abandoned (inputs are respendable). Only available for the 'send' category of transactions.
  abandoned?: boolean;
  // A comment for the address/transaction, if any
  label?: string;
  // the vout value
  vout: number;
}

export interface listsinceblock {
  transactions: Array<extendedtransactiondescription>;
  // structure is the same as "transactions" above, only present if include_removed=true>
  // Note: transactions that were re-added in the active chain will appear as-is in this array, and may thus have a positive confirmation count.
  removed?: Array<extendedtransactiondescription>;
  // (string) The hash of the block (target_confirmations-1) from the best block on the main chain, or the genesis hash if the referenced block does not exist yet. This is typically used to feed back into listsinceblock the next time you call it. So you would generally use a target_confirmations of say 6, so you will be continually re-notified of transactions until they've reached 6 confirmations plus any new ones
  lastblock: string;
};

export type listtransactions = Array<extendedtransactiondescription>;

export type listunspent = Array<{
  // the transaction id
  txid: string;
  // the vout value
  vout: number;
  // the bitcoin address
  address?: string;
  // The associated label, or "" for the default label
  label?: string;
  // the script key
  scriptPubKey: string;
  // the transaction output amount in BTC
  amount: number;
  // The number of confirmations
  confirmations: number;
  // The number of in-mempool ancestor transactions, including this one (if transaction is in the mempool)
  ancestorcount?: number;
  // The virtual transaction size of in-mempool ancestors, including this one (if transaction is in the mempool)
  ancestorsize?: number;
  // The total fees of in-mempool ancestors (including this one) with fee deltas used for mining priority in sat (if transaction is in the mempool)
  ancestorfees?: number;
  // The redeemScript if scriptPubKey is P2SH
  redeemScript?: string;
  // witnessScript if the scriptPubKey is P2WSH or P2SH-P2WSH
  witnessScript?: string;
  // Whether we have the private keys to spend this output
  spendable: boolean;
  // Whether we know how to spend this output, ignoring the lack of keys
  solvable: boolean;
  // (only present if avoid_reuse is set) Whether this output is reused/dirty (sent to an address that was previously spent from)
  reused?: boolean;
  // (only when solvable) A descriptor for spending this output
  desc?: string;
  // List of parent descriptors for the scriptPubKey of this coin.
  parent_desc?: string[];
  // Whether this output is considered safe to spend. Unconfirmed transactions from outside keys and unconfirmed replacement transactions are considered unsafe and are not eligible for spending by fundrawtransaction and sendtoaddress.
  safe: boolean;
}>;

export interface listwalletdir {
  wallets: Array<{
    // The wallet name
    name: string;
  }>
};

export type listwallets = string[];

export interface loadwallet {
  // The wallet name if loaded successfully.
  name: string;
  // Warning message if wallet was not loaded cleanly.
  warning: string;
}

export type lockunspent = boolean;

export interface migratewallet {
  // The name of the primary migrated wallet
  wallet_name: string;
  // The name of the migrated wallet containing the watchonly scripts
  watchonly_name?: string;
  // The name of the migrated wallet containing solvable but not watched scripts
  solvables_name?: string;
  // The location of the backup of the original wallet
  backup_path: string;
}

export type newkeypool = null;

export interface psbtbumpfee {
  // The base64-encoded unsigned PSBT of the new transaction.
  psbt: string;
  // The fee of the replaced transaction.
  origfee: number;
  // The fee of the new transaction.
  fee: number;
  // Errors encountered during processing (may be empty).
  errors: string[];
}

export type removeprunedfunds = null;

export interface rescanblockchain {
  // The block height where the rescan started (the requested height or 0)
  start_height: number;
  // The height of the last rescanned block. May be null in rare cases if there was a reorg and the call didn't scan any blocks because they were already scanned in the background.
  stop_height: number | null;
}

export interface restorewallet {
  // The wallet name if restored successfully.
  name: string;
  // Warning message if wallet was not loaded cleanly.
  warning: string;
}

export interface sendOptionsInput {
  // Automatically include coins from the wallet to cover the target amount.
  add_inputs?: boolean;
  // Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
  // Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
  // If that happens, you will need to fund the transaction with different inputs and republish it.
  include_unsafe?: boolean;
  // When false, returns a serialized transaction which will not be added to the wallet or broadcast
  add_to_wallet?: boolean;
  // The bitcoin address to receive the change
  change_address?: string;
  // The index of the change output
  change_position?: number;
  // The output type to use. Only valid if change_address is not specified. Options are "legacy", "p2sh-segwit", "bech32" and "bech32m".
  change_type?: 'legacy' | 'p2sh-segwit' | 'bech32' | 'bech32m';
  // Specify a fee rate in sat/vB.
  fee_rate?: number | string;
  // Also select inputs which are watch only.
  // Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,
  // e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.
  include_watching?: boolean;
  // Specify inputs instead of adding them automatically. A JSON array of JSON objects
  inputs?: Array<{
    // The transaction id
    txid: string;
    // The output number
    vout: number;
    // The sequence number
    sequence: number;
  }>;
}

export interface send {
  // If the transaction has a complete set of signatures
  complete: boolean;
  // The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.
  txid?: string;
  // If add_to_wallet is false, the hex-encoded raw transaction with signature(s)
  hex?: string;
  // If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction
  psbt?: string;
}

export interface sendallOptionsInput {
  // When false, returns the serialized transaction without broadcasting or adding it to the wallet
  add_to_wallet?: boolean;
  // Specify a fee rate in sat/vB.
  fee_rate?: number | string;
  // Also select inputs which are watch-only.
  // Only solvable inputs can be used. Watch-only destinations are solvable if the public key and/or output script was imported,
  // e.g. with 'importpubkey' or 'importmulti' with the 'pubkeys' or 'desc' field.
  include_watching?: boolean;
  // Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with send_max.
  inputs?: Array<{
    // The transaction id
    txid: string;
    // The output number
    vout: number;
    // The sequence number
    sequence?: number;
  }>;
  // Raw locktime. Non-0 value also locktime-activates inputs
  locktime?: number;
  // Lock selected unspent outputs
  lock_unspents?: boolean;
  // Always return a PSBT, implies add_to_wallet=false
  psbt?: boolean;
  // When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.
  send_max?: boolean;
  // Confirmation target in blocks
  target?: number;
  // The fee estimate mode, must be one of (case insensitive):
  // "unset"
  // "economical"
  // "conservative"
  estimate_mode?: 'unset' | 'economical' | 'conservative';
  // Marks this transaction as BIP125-replaceable.
  // Allows this transaction to be replaced by a transaction with higher fees
  replaceable?: boolean;
  // Keys and scripts needed for producing a final transaction with a dummy signature.
  // Used for fee estimation during coin selection.
  solving_data?: Array<{
    // Public keys involved in this transaction.
    pubkeys?: string[];
    // Scripts involved in this transaction.
    scripts?: string[];
    // Descriptors that provide solving data for this transaction.
    descriptors?: string[];
  }>;
}

export interface sendall {
  // If the transaction has a complete set of signatures
  complete: boolean;
  // The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.
  txid?: string;
  // If add_to_wallet is false, the hex-encoded raw transaction with signature(s)
  hex?: string;
  // If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction
  psbt?: string;
}

// @todo can make generic based on Verbose?
export type sendmany = string | {
  // The transaction id for the send. Only 1 transaction is created regardless of
  // the number of addresses.
  txid: string;
  // The transaction fee reason.
  fee_reason: string;
}

// @todo can make generic based on Verbose?
export type sendtoaddress = string | {
  // The transaction id for the send. Only 1 transaction is created regardless of
  // the number of addresses.
  txid: string;
  // The transaction fee reason.
  fee_reason: string;
}

export type sethdseed = null;

export type setlabel = null;

export type settxfee = boolean;

export interface setwalletflag {
  // The name of the flag that was modified
  flag_name: string;
  // The new state of the flag
  flag_state: boolean;
  // Any warnings associated with the change
  warnings?: string;
}

export type signmessage = string;

export interface signrawtransactionwithwallet {
  // The hex-encoded raw transaction with signature(s)
  hex: string;
  // If the transaction has a complete set of signatures
  complete: boolean;
  // Script verification errors (if there are any)
  errors?: Array<{
    // The hash of the referenced, previous transaction
    txid: string;
    // The index of the output to spent and used as input
    vout: number;
    witness: string[];
    // The hex-encoded signature script
    scriptSig: string;
    // Script sequence number
    sequence: number;
    // Verification or signing error related to the input
    error: string;
  }>;
}

export interface simulaterawtransaction {
  // The wallet balance change (negative means decrease).
  balance_change: number;
}

export interface unloadwallet {
  // Warning message if wallet was not unloaded cleanly.
  warning?: string;
}

export interface upgradewallet {
  // Name of wallet this operation was performed on
  wallet_name: string;
  // Version of wallet before this operation
  previous_version: number;
  // Version of wallet after this operation
  current_version: number;
  // Description of result, if no error
  result?: string;
  // Error message (if there is one)
  error?: string;
}

export interface walletcreatefundedpsbtOptionsInput {
  // Automatically include coins from the wallet to cover the target amount.
  add_inputs?: boolean;
  // Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
  // Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
  // If that happens, you will need to fund the transaction with different inputs and republish it.
  include_unsafe?: boolean;
  // The bitcoin address to receive the change
  changeAddress?: string;
  // The index of the change output
  changePosition?: number;
  // The output type to use. Only valid if changeAddress is not specified. Options are "legacy", "p2sh-segwit", "bech32", and "bech32m".
  change_type?: 'legacy' | 'p2sh-segwit' | 'bech32' | 'bech32m';
  // Also select inputs which are watch only
  includeWatching?: boolean;
  // Lock selected unspent outputs
  lockUnspents?: boolean;
  // Specify a fee rate in sat/vB.
  fee_rate?: number | string;
  // Specify a fee rate in BTC/kvB.
  feeRate?: number | string;
  // The outputs to subtract the fee from.
  // The fee will be equally deducted from the amount of each specified output.
  // Those recipients will receive less bitcoins than you enter in their corresponding amount field.
  // If no outputs are specified here, the sender pays the fee.
  subtractFeeFromOutputs?: number[];
  // Confirmation target in blocks
  conf_target?: number;
  // The fee estimate mode, must be one of (case insensitive):
  // "unset"
  // "economical"
  // "conservative"
  estimate_mode?: 'unset' | 'economical' | 'conservative';
  // Marks this transaction as BIP125-replaceable.
  // Allows this transaction to be replaced by a transaction with higher fees
  replaceable?: boolean;
  // Keys and scripts needed for producing a final transaction with a dummy signature.
  // Used for fee estimation during coin selection.
  solving_data?: Array<{
    // Public keys involved in this transaction.
    pubkeys?: string[];
    // Scripts involved in this transaction.
    scripts?: string[];
    // Descriptors that provide solving data for this transaction.
    descriptors?: string[];
  }>;
}

export interface walletcreatefundedpsbt {
  // The resulting raw transaction (base64-encoded string)
  psbt: string;
  // Fee in BTC the resulting transaction pays
  fee: number;
  // The position of the added change output, or -1
  changepos: number;
}

export interface walletdisplayaddress {
  // The address as confirmed by the signer
  address: string;
}

export type walletlock = null;

export type walletpassphrase = null;

export type walletpassphrasechange = null;

export interface walletprocesspsbt {
  // The base64-encoded partially signed transaction
  psbt: string;
  // If the transaction has a complete set of signatures
  complete: boolean;
}